─ section Imager parents standard_toolkit
└

─ [ DEVICE, SECTOR ] └

─
  BIT ::= ONE | ZERO
└

The three types of devices that imaging can be done in
deadbox - the device remains unchanged throught the image creation
pTwo - the device may have been changed during this process. It is not known how much of the data has been changed
remote - the data is on something like a server so NON of the data is origional
corrupted - a set of all sector addresses that are corrupted
╷
  deadbox, pTwo, remote: 𝔽 DEVICE
  corrupted: DEVICE → 𝔽 ℕ
|
  deadbox ∩ pTwo ∩ remote = ∅
└

drives map a dirve to a releation that maps a sequence of sectors (represented as a sequence of bits). The position in the sequence is the address for that sector
images is the new disk images that will be created
		old unchanged devices → new images
changed releates the drives to the addresses that have been changed when extracting the data
---
  dom images ⊆ deadbox -> not sure if this line is correct 

All drives will be in changed (if they are unchanged then they will point to an empty set)
All of the created images will be in the drives domain
All of the addresses that have been changed are a subset of all of the addresses on the drive - addresses are the sequence position 
deadboxes have no address that have been changed
pTwo and remote devices can have any number of addresses changed
┌ World
  drives: DEVICE → seq( seq( BIT ) )
  images: DEVICE ⤔ DEVICE
  changed: DEVICE ⇸ 𝔽 ℕ
|
  deadbox ⊆ dom images
  dom changed =  dom images
  dom drives ⊆ ran images
  ∀i: dom images ⦁  changed i ⊆ dom ( drives i )
  changed⦇ ran images ∩ deadbox ⦈ = { }
  changed⦇ ran images ∩ (pTwo ∪ remote) ⦈ ⊆ ℙ ℕ
└

At initialisation there are no images that have been created
┌ WorldInit
  World ′
|
  images′ = ∅
└

FATdevices - set of all devices that are currently in the FAT system
BootSectors - the boot sectors from all of the drives in the system
FAT - the File Allocation Tables from all of the drives in the system
Data - the data sectors from all of the drives in the system
RootDirectory - the Root Directory information sectors from all of the drives in the system
---
All FAT devices must be in the devices releation from world
all devices in the FAT system must have their partitions in each of the partition releations
┌ FatSystem
  World
  FATdevices: 𝔽 DEVICE
  BootSectors: DEVICE → seq( seq( BIT ) )
  FAT: DEVICE → seq( seq( BIT ) )
  Data: DEVICE → seq( seq( BIT ) )
  RootDirectory: DEVICE → seq( seq( BIT ) )
|
  FATdevices ⊆ dom drives
  dom BootSectors = FATdevices
  dom FAT = FATdevices
  dom Data = FATdevices
  dom RootDirectory = FATdevices
└

At initialisation there are no drives that are in the FAT system
┌ FatSystemInit
  FatSystem ′
|
  FATdevices′ = ∅
└

newDrive? - the new drive to add to the FAT system
partitionPinters? - pointers for each partition needed by a FAT system. The pointer points to the first sector in that partition
---
There can only be 4 pointers
the first partition pointer must be 1 (the boot drive must always be at the start of the drive)

The new drive must not already be in the FAT system
The new drive must already be in the world

splits up the new drive into partitions and adds them to the releations for each partition in the FAT system based on the pointers  
┌ AddFatDrive
  ΔFatSystem
  newDrive?: DEVICE
  partitionPinters?: iseq( ℕ↘1↖ )
|
  #partitionPinters? = 4
  partitionPinters?(1) = 1
    
  newDrive? ∉ FATdevices
  newDrive? ∈ dom drives
  
  FATdevices′ = FATdevices ∪ { newDrive? }
  ∀sectorAddress: dom( drives newDrive? ) ⦁ ∃s: seq( seq( BIT ) ) | BootSectors′ = BootSectors ∪ { newDrive? ↦ s } ⦁ s = s ⊕ {sectorAddress ↦ drives newDrive? sectorAddress} ∧ sectorAddress ≤ partitionPinters?(2)
  ∀sectorAddress: dom( drives newDrive? ) ⦁ ∃s: seq( seq( BIT ) ) | FAT′ = FAT ∪ { newDrive? ↦ s } ⦁ s = s ⊕ {sectorAddress ↦ drives newDrive? sectorAddress} ∧ sectorAddress ≥ partitionPinters?(2) ∧ sectorAddress ≤ partitionPinters?(3)
  ∀sectorAddress: dom( drives newDrive? ) ⦁ ∃s: seq( seq( BIT ) ) | Data′ = Data ∪ { newDrive? ↦ s } ⦁ s = s ⊕ {sectorAddress ↦ drives newDrive? sectorAddress} ∧ sectorAddress ≥ partitionPinters?(3) ∧ sectorAddress ≤ partitionPinters?(4)
  ∀sectorAddress: dom( drives newDrive? ) ⦁ ∃s: seq( seq( BIT ) ) | RootDirectory′ = RootDirectory ∪ { newDrive? ↦ s } ⦁ s = s ⊕ {sectorAddress ↦ drives newDrive? sectorAddress} ∧ sectorAddress ≥ partitionPinters?(4)
└

┌ DeleteFile
  ΔFatSystem
  FileName?: seq( BIT )
  dev?: DEVICE
|
  dev? ∈ FATdevices
└


source? - source drive 
target? - the drive that the image will be releated to
image - created image
sDrive - a temp var for the source drive with the changed sectors removed from the sequence
errorSectors! - set of all addresses where there was a corrupted sector/error
---
the target drive has not already been used to create another image
there is no changes to any device during this operation
the source drive is unchanged during this operation
sDrives is equal to the origional source drive without the changed sectors in it
if the sector is NOT corrupted then the sector is overwritten to the new image in the same position 
If the sector is corrupted then the address is added to errorSectors! and a sequence of all ZEROs is put in the new image at the address of the corrupted sector
adds the image releating to the target disk to the drives
adds the device with the new image on it to the images releation
┌ CreateImage
  ΔWorld
  source?, target? : DEVICE
  image, sDrive: seq( seq( BIT ) )
  errorSectors!: 𝔽 ℕ
|
  (target?) ∉ dom drives
  changed′ = changed
  drives′ source? = drives source?
  ∀sectorAddress: dom (drives source?) | sDrive = sDrive ⊕ { sectorAddress ↦ (drives source?) sectorAddress } ⦁ sectorAddress ∉ changed source?
  ∀sectorAddress: dom sDrive | image = image ⊕ { sectorAddress ↦ sDrive sectorAddress } ⦁ sectorAddress ∉ (corrupted source?) 
  ∀sectorAddress: dom sDrive ⦁ ∃s: seq( BIT ) | image = image ⊕ { sectorAddress ↦ s } ∧ errorSectors! = errorSectors! ∪ { sectorAddress } ⦁ 
  												   sectorAddress ∈ (corrupted source?) ∧ #s = #(sDrive sectorAddress) ∧ s ↾ { ONE } = ∅   
  drives′ = drives ∪ { target? ↦  image }
  images′ = images ⊕ { source? ↦ target? }
└

this operation will not find a bit pattern that spans different sectors

drive? - the drive that has the image that you want to search on it
bitPattern - the pattern of bits that you want to search for 
---
if there is no bit pattern to search for then there is no locations for it in the searched image
patternLocation! - a set of sector addresses that have that bit pattern in it
	"infix" matches one sequence into another (like in) -> p119 in z-manual
┌ SearchImage
  ΞWorld
  drive?: DEVICE
  bitPattern?: seq( BIT )
  patternLocation!: 𝔽 ℕ
|
  drive? ∈ dom drives
  bitPattern? = ∅ ⇒ patternLocation! = ∅
  ∀sectorAddress: dom (drives drive?) ⦁ bitPattern? infix (drives drive? sectorAddress) ⇒ patternLocation! = patternLocation! ∪ { sectorAddress }
└